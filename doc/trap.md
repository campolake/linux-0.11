##中断机制

##中断机制的产生
CPU作为电脑的核心，要用众多的外设进行交互。
如何交互呢，我们最先想到的就是“轮循机制”，CPU定期的去检查一下所有连接的外设，看看有没有需要自己处理的。这种机制实现起来比较简单，但是由于外设运行速度与CPU相比要慢很多，在CPU轮询是大部分没有准备好，浪费了太多的CPU时间，运行效率太低。
于是人们开始冥思苦想，既然外设运行速率低，那么能不能引入一直机制，CPU不直接查询外设呢？比如引入一个设备，让它专门跟外设交互，如果有外设需要处了，这个设备在发送一个信号给CPU“X设备需要你来处理一下”，这个指令放到CPU的一个特殊的地方，CPU在每一条指令执行完毕后检查下这个地方是不是有信号要处理。CPU对这个信号的检测由专门的硬件来实现，可以实现的很高效。这种机制呢就叫“中断”，顾名思义就是中断CPU当前的指令执行，来处理一下外设的信。那个引入的中间设备就是中断处理器，Intel早期的cpu中用8259A芯片来实现。

后来发现中断处理器太好用了，跟CPU的配合也非常默契。CPU的一切外部事件都交由中断处理器来管理，中断处理器不仅仅管理硬件的中断信号,还可以处理由指令INTX触发的软中断，在Linux中跟内核的很多交互都是通过软中断来实现的，那么为什么不用函数调用来实现呢？
1. 用户的程序是在用户空间运行的，即CPU运行在用户态，而内核是运行在内核态的，直接函数调用不太好实现用户态到内核态的转变？
2. 待续

## linux中断的实现
CPU处理的中断由很多，于是CPU给每个中断编了一个唯一的序号，每个中断产生后肯定要执行一段代码来处理中断。于是设计了一个中断描述符表，中断描述符表描述了当产生一个中断时需要调用的处理程序存放在什么地方。并且把这个中断描述表的首地址放到一个专门的寄存器（IDTR）中，当由中断产生时，CPU通过这个寄存器找到中断描述表，并且根据中断号在中断描述符表中找到对应的处理程序，并且跳转到那个地方开始执行，中断执行完毕后，CPU再继续回到中断产生前的位置开始继续执行。
     
<img src="https://github.com/campolake/linux-0.11/blob/master/doc/img/trap.jpg">
引用在赵炯博士 Linux内核代码完全注释